<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <link rel="icon" href="atomo.png" size="32x32" />
  <title>Átomo de Oxígeno 3D — etiquetas corregidas (v6.6)</title>
  <meta name="theme-color" content="#14b8a6" />
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#0b1220; color:#e5e7eb; }
    #app { position:fixed; inset:0; }
    .hud {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: 16px; display:flex; gap:.5rem; align-items:center; flex-wrap:wrap;
      background: rgba(2,6,23,.7); border:1px solid rgba(148,163,184,.25);
      padding: .75rem 1rem; border-radius: 14px; backdrop-filter: blur(8px);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto;
      box-shadow: 0 8px 30px rgba(0,0,0,.35);
    }
    .btn { appearance:none; border:1px solid rgba(148,163,184,.35); background:#0f172a; color:#e5e7eb; 
      padding:.5rem .8rem; border-radius:12px; cursor:pointer; font-weight:600; font-size:14px; }
    .btn.primary { background:#14b8a6; border-color:#2dd4bf; color:#001010; }
    .badge { font-size:12px; opacity:.9 }
    .legend { position:fixed; top:12px; left:12px; right:12px; display:flex; gap:.5rem; align-items:center; flex-wrap:wrap;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto; }
    .legend > * { background: rgba(2,6,23,.7); border:1px solid rgba(148,163,184,.25); padding:.5rem .7rem; border-radius: 12px; }
    .dot { width:12px; height:12px; border-radius:999px; display:inline-block; margin-right:6px; vertical-align:middle; }
    .dot.nucleo { background:#f59e0b; } .dot.electron { background:#34d399; } .dot.orbita { background:#a78bfa; }
    .dot.proton { background:#ef4444; } .dot.neutron { background:#60a5fa; }
    #errorBanner { position: fixed; top: 0; left: 0; right: 0; background: #991b1b; color: #fff; padding: 10px 14px; font-family: ui-sans-serif, system-ui;
      display: none; z-index: 9999; }
  </style>
</head>
<body>
  <div id="errorBanner"></div>
  <div id="app"></div>

  <div class="legend">
    <div><span class="dot nucleo"></span> Núcleo (p<sup>+</sup>, n<sup>0</sup>)</div>
    <div><span class="dot proton"></span> Protones (p<sup>+</sup>)</div>
    <div><span class="dot neutron"></span> Neutrones (n<sup>0</sup>)</div>
    <div><span class="dot electron"></span> Electrones (e<sup>-</sup>)</div>
    <div><span class="dot orbita"></span> Órbitas elípticas</div>
    <div class="badge">Oxígeno (Z=8) · K=2, L=6 · Núcleo: 8 p<sup>+</sup>, 8 n<sup>0</sup></div>
  </div>

  <div class="hud" id="hud">
    <button id="gyroBtn" class="btn primary">Activar giroscopio</button>
    <button id="labelsBtn" class="btn">Mostrar etiquetas</button>
    <button id="autoBtn" class="btn">Auto-rotar</button>
    <button id="resetBtn" class="btn">Reiniciar vista</button>
    <span class="badge">Arrastra para rotar · pellizca para zoom</span>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
    const banner = document.getElementById('errorBanner');
    function showErr(msg){ banner.style.display='block'; banner.textContent=msg; console.error(msg); }
    window.addEventListener('error', e=> showErr('Error en el visor: ' + (e?.message || e)));

    (function(){
      try{
        if (!window.THREE){ showErr('No se cargó THREE.js (CDN). Verifica conexión o usa versión offline.'); return; }
        const DEG = (THREE.MathUtils && THREE.MathUtils.degToRad) ? THREE.MathUtils.degToRad : (d=>d*Math.PI/180);

        const app=document.getElementById('app');
        const scene=new THREE.Scene(); scene.background=new THREE.Color(0x0b1220);
        const camera=new THREE.PerspectiveCamera(55, innerWidth/innerHeight, .1, 1000); camera.position.set(0,2.1,7.5);
        const renderer=new THREE.WebGLRenderer({antialias:true}); renderer.setPixelRatio(Math.min(devicePixelRatio,2)); renderer.setSize(innerWidth,innerHeight);
        app.appendChild(renderer.domElement);

        // Luces
        scene.add(new THREE.AmbientLight(0xffffff,.6));
        const key=new THREE.PointLight(0xffffff,1.1); key.position.set(5,5,6); scene.add(key);
        const rim=new THREE.PointLight(0x66ccff,.8); rim.position.set(-6,-3,-4); scene.add(rim);

        // Materiales
        const electronMat=new THREE.MeshPhysicalMaterial({color:0x34d399, roughness:.35, metalness:.25});
        const orbitaMat=new THREE.LineBasicMaterial({color:0xa78bfa, transparent:true, opacity:.6});
        const protonMat=new THREE.MeshPhysicalMaterial({color:0xef4444, roughness:.3, metalness:.2});
        const neutronMat=new THREE.MeshPhysicalMaterial({color:0x60a5fa, roughness:.35, metalness:.15});

        // Núcleo transparente
        const nucleusRadius = 1.15;
        const nucleoMat=new THREE.MeshPhysicalMaterial({
          color: 0xf59e0b, roughness: 0.2, metalness: 0.15, clearcoat: 0.2,
          transparent: true, opacity: 0.42, depthWrite: false, side: THREE.DoubleSide
        });
        const nucleo=new THREE.Mesh(new THREE.SphereGeometry(nucleusRadius,64,64), nucleoMat); scene.add(nucleo);

        // ========= Nucleones =========
        const nucleonR = 0.22;
        const innerR = nucleusRadius - (nucleonR + 0.10);
        const nucleones = new THREE.Group(); nucleo.add(nucleones);

        function v(x,y,z){ return new THREE.Vector3(x,y,z); }
        const cubeDirs = [ v(1,1,1), v(1,1,-1), v(1,-1,1), v(1,-1,-1), v(-1,1,1), v(-1,1,-1), v(-1,-1,1), v(-1,-1,-1) ].map(vv => vv.normalize());
        const rotQ = new THREE.Quaternion().setFromEuler(new THREE.Euler(DEG(25), DEG(35), DEG(-15)));
        const cubeDirsRot = cubeDirs.map(vv => vv.clone().applyQuaternion(rotQ));

        const nucleonGeo = new THREE.SphereGeometry(nucleonR, 24, 24);
        const protons = [], neutrons = [];
        const jitterAmp = 0.08;

        function placeAt(dir, mat, arr){
          const base = dir.clone().multiplyScalar(innerR);
          base.add(new THREE.Vector3((Math.random()-0.5)*jitterAmp, (Math.random()-0.5)*jitterAmp, (Math.random()-0.5)*jitterAmp));
          base.setLength(Math.min(base.length(), innerR));
          const m = new THREE.Mesh(nucleonGeo, mat);
          m.position.copy(base);
          m.userData = { base: base.clone(), phase: Math.random()*Math.PI*2 };
          nucleones.add(m); arr.push(m);
          return m;
        }
        for(let i=0;i<8;i++){ placeAt(cubeDirs[i], protonMat, protons); }
        for(let i=0;i<8;i++){ placeAt(cubeDirsRot[i], neutronMat, neutrons); }

        // ========= Órbitas y electrones =========
        const orbitsGroup=new THREE.Group(); scene.add(orbitsGroup);
        const K=new THREE.Group(), L=new THREE.Group(); orbitsGroup.add(K); orbitsGroup.add(L);

        function ellipseLine(a,b,seg=240){
          const pts=[]; for(let i=0;i<seg;i++){ const t=i/seg*Math.PI*2; pts.push(new THREE.Vector3(a*Math.cos(t),0,b*Math.sin(t))); }
          return new THREE.LineLoop(new THREE.BufferGeometry().setFromPoints(pts), orbitaMat);
        }
        const aK=2.4,bK=2.0, aL=3.8,bL=3.0;
        const orbitK=ellipseLine(aK,bK), orbitL=ellipseLine(aL,bL);
        K.add(orbitK); L.add(orbitL);
        K.rotation.set(DEG(78), DEG(-10), DEG(6));
        L.rotation.set(DEG(62), DEG(28),  DEG(-12));

        const eGeo=new THREE.SphereGeometry(.20,24,24);
        function addElectrons(group,count,a,b,speed,phase0=0){
          const arr=[];
          for(let i=0;i<count;i++){
            const m=new THREE.Mesh(eGeo,electronMat);
            const phase=phase0 + i*(Math.PI*2/count);
            m.userData={a,b,phase,speed:speed*(0.95+0.1*Math.random())};
            group.add(m); arr.push(m);
          }
          return arr;
        }
        const eK=addElectrons(K,2,aK,bK,1.0);
        const eL=addElectrons(L,6,aL,bL,0.7,Math.PI/6);

        // ===== Etiquetas (sprites) — FIX recorte =====
        function makeSprite(text, worldSize=0.9){
          const pad = 14;
          const fontSize = 24;
          const font = `700 ${fontSize}px ui-sans-serif, -apple-system, Segoe UI, Roboto`;
          const c = document.createElement('canvas');
          const x = c.getContext('2d');
          x.font = font;
          const lines = String(text).split('\n');
          // medir alto real de la fuente
          const metr = x.measureText('Mg');
          const ascent = metr.actualBoundingBoxAscent || fontSize*0.8;
          const descent = metr.actualBoundingBoxDescent || fontSize*0.2;
          const fontHeight = ascent + descent;
          const lineHeight = Math.ceil(fontHeight * 1.2);
          const textWidth = Math.max(...lines.map(l => x.measureText(l).width));
          const width = Math.ceil(textWidth + pad*2);
          const height = Math.ceil(lineHeight*lines.length + pad*2);
          const scale = Math.max(2, Math.min(4, Math.round((window.devicePixelRatio||2))));
          c.width = width * scale;
          c.height = height * scale;
          x.scale(scale, scale);
          x.font = font;
          // fondo redondeado
          x.fillStyle = 'rgba(2,6,23,0.85)';
          x.strokeStyle = 'rgba(148,163,184,0.35)';
          x.lineWidth = 1;
          const r = 10;
          x.beginPath();
          x.moveTo(pad+r, pad);
          x.lineTo(width-pad-r, pad);
          x.quadraticCurveTo(width-pad, pad, width-pad, pad+r);
          x.lineTo(width-pad, height-pad-r);
          x.quadraticCurveTo(width-pad, height-pad, width-pad-r, height-pad);
          x.lineTo(pad+r, height-pad);
          x.quadraticCurveTo(pad, height-pad, pad, height-pad-r);
          x.lineTo(pad, pad+r);
          x.quadraticCurveTo(pad, pad, pad+r, pad);
          x.closePath();
          x.fill();
          x.stroke();
          // texto
          x.fillStyle = '#e5e7eb';
          x.textBaseline = 'alphabetic';
          lines.forEach((l,i) => {
            const tm = x.measureText(l);
            const y = pad + i*lineHeight + ascent + (lineHeight - fontHeight)/2;
            x.fillText(l, (width - tm.width)/2, y);
          });
          const tex = new THREE.CanvasTexture(c);
          tex.minFilter = THREE.LinearFilter;
          tex.magFilter = THREE.LinearFilter;
          tex.generateMipmaps = false;
          const mat = new THREE.SpriteMaterial({ map: tex, depthTest: false, depthWrite: false, transparent: true });
          const sp = new THREE.Sprite(mat);
          sp.scale.set(worldSize * (width/height), worldSize, 1);
          sp.renderOrder = 999;
          return sp;
        }
        const lN=makeSprite('Núcleo',.9); lN.position.set(0,1.6,0); nucleo.add(lN);
        const lK=makeSprite('Capa K — 2 e⁻',.9); lK.position.set(aK+.3, 0.0, 0.0); K.add(lK);
        const lL=makeSprite('Capa L — 6 e⁻',.9); lL.position.set(aL+.3, 0.0, 0.0); L.add(lL);
        const spP=makeSprite('p⁺',0.55); protons[0].add(spP); spP.position.set(0, 0.40, 0);
        const spN=makeSprite('n⁰',0.55); neutrons[0].add(spN); spN.position.set(0, 0.40, 0);
        const sprites=[lN,lK,lL,spP,spN]; sprites.forEach(s=> s.visible=false);

        // Controles
        class SimpleOrbit{ constructor(cam,dom,target=new THREE.Vector3()){
          this.camera=cam; this.dom=dom; this.target=target.clone(); this.spherical=new THREE.Spherical();
          const off=new THREE.Vector3().copy(cam.position).sub(this.target); this.spherical.setFromVector3(off);
          this.minDistance=3.2; this.maxDistance=18; this.rotateSpeed=1.0; this.zoomSpeed=1.0; this.damping=.1;
          this._dTh=0; this._dPh=0; this._scale=1; this.autoRotate=false; this.autoRotateSpeed=.7;
          this._state=null; this._p0=new THREE.Vector2(); this._touchDist=0;
          dom.addEventListener('pointerdown',e=>{dom.setPointerCapture(e.pointerId); this._state='rot'; this._p0.set(e.clientX,e.clientY);});
          addEventListener('pointermove',e=>{ if(this._state!=='rot') return; const dx=(e.clientX-this._p0.x)/dom.clientHeight, dy=(e.clientY-this._p0.y)/dom.clientHeight; this._dTh-=2*Math.PI*dx*this.rotateSpeed; this._dPh-=2*Math.PI*dy*this.rotateSpeed*.6; this._p0.set(e.clientX,e.clientY);});
          addEventListener('pointerup',()=>this._state=null,{passive:true});
          dom.addEventListener('wheel',e=>{e.preventDefault(); const d=e.deltaY>0?1:-1, f=1+.08*this.zoomSpeed; this._scale*=d>0?f:1/f;},{passive:false});
          dom.addEventListener('touchstart',e=>{ if(e.touches.length===1){this._state='rot'; this._p0.set(e.touches[0].clientX,e.touches[0].clientY);} else if(e.touches.length===2){this._state='zoom'; const dx=e.touches[0].clientX-e.touches[1].clientX, dy=e.touches[0].clientY-e.touches[1].clientY; this._touchDist=Math.hypot(dx,dy);} },{passive:false});
          dom.addEventListener('touchmove',e=>{ if(this._state==='rot'&&e.touches.length===1){ const x=e.touches[0].clientX,y=e.touches[0].clientY, dx=(x-this._p0.x)/dom.clientHeight, dy=(y-this._p0.y)/dom.clientHeight; this._dTh-=2*Math.PI*dx*this.rotateSpeed; this._dPh-=2*Math.PI*dy*this.rotateSpeed*.6; this._p0.set(x,y);} else if(this._state==='zoom'&&e.touches.length===2){ const dx=e.touches[0].clientX-e.touches[1].clientX, dy=e.touches[0].clientY-e.touches[1].clientY, dist=Math.hypot(dx,dy), f=1+(Math.abs(dist-this._touchDist)/200)*this.zoomSpeed; this._scale*= dist<this._touchDist ? f : 1/f; this._touchDist=dist;} e.preventDefault(); },{passive:false});
          dom.addEventListener('touchend',()=>this._state=null);
        }
          reset(){ const off=new THREE.Vector3(0,2.1,7.5).sub(this.target); this.spherical.setFromVector3(off); }
          update(dt){ if(this.autoRotate) this._dTh -= this.autoRotateSpeed*dt; this.spherical.theta+=this._dTh*this.damping; this.spherical.phi+=this._dPh*this.damping; this.spherical.makeSafe();
            this.spherical.radius*=this._scale; this.spherical.radius=Math.min(this.maxDistance,Math.max(this.minDistance,this.spherical.radius));
            this._dTh*=(1-this.damping); this._dPh*=(1-this.damping); this._scale=1; const off=new THREE.Vector3().setFromSpherical(this.spherical); this.camera.position.copy(this.target).add(off); this.camera.lookAt(this.target); } }
        const orbit=new SimpleOrbit(camera, renderer.domElement);

        // Giroscopio
        let gyro=false, bB=null, bG=null;
        function enableGyro(){
          const any=window.DeviceOrientationEvent;
          const attach=()=>{ gyro=true; bB=null; bG=null; addEventListener('deviceorientation',e=>{ if(!gyro) return; if(bB===null){ bB=e.beta||0; bG=e.gamma||0; return; } const dB=(e.beta||0)-bB, dG=(e.gamma||0)-bG; orbit._dPh -= (dB*Math.PI/180)*.5; orbit._dTh += (dG*Math.PI/180)*.5; }); };
          if(any && typeof any.requestPermission==='function'){ any.requestPermission().then(s=>{ if(s==='granted') attach(); else alert('Permiso denegado.'); }).catch(()=>{}); } else attach();
        }

        // HUD
        const gyroBtn=document.getElementById('gyroBtn'), labelsBtn=document.getElementById('labelsBtn'), autoBtn=document.getElementById('autoBtn'), resetBtn=document.getElementById('resetBtn');
        let labelsVisible=false;
        labelsBtn.addEventListener('click',()=>{
          labelsVisible=!labelsVisible;
          sprites.forEach(s=> s.visible=labelsVisible);
          labelsBtn.textContent = labelsVisible ? 'Ocultar etiquetas' : 'Mostrar etiquetas';
          labelsBtn.classList.toggle('primary', labelsVisible);
        });
        autoBtn.addEventListener('click',()=>{ orbit.autoRotate=!orbit.autoRotate; autoBtn.classList.toggle('primary', orbit.autoRotate); autoBtn.textContent=orbit.autoRotate?'Detener auto-rotación':'Auto-rotar'; });
        resetBtn.addEventListener('click',()=> orbit.reset());
        gyroBtn.addEventListener('click',()=>{ if(!gyro){ enableGyro(); gyroBtn.textContent='Giroscopio activo'; gyroBtn.disabled=true; } });

        // Animación
        const clock=new THREE.Clock();
        function stepElectrons(arr,dt){ for(const m of arr){ const d=m.userData; d.phase+=d.speed*dt; m.position.set(d.a*Math.cos(d.phase),0,d.b*Math.sin(d.phase)); } }
        function stepNucleons(arr,amp,t){
          for(const m of arr){
            const base = m.userData.base;
            const ph = m.userData.phase;
            m.position.set(base.x + Math.sin(t*1.8 + ph)*amp, base.y + Math.cos(t*2.1 + ph)*amp*0.9, base.z + Math.sin(t*1.6 + ph*1.3)*amp*0.8);
          }
        }
        function animate(){ const dt=clock.getDelta(); const t=clock.elapsedTime;
          nucleo.scale.setScalar(1+Math.sin(t*1.6)*.015);
          stepElectrons(eK,dt); stepElectrons(eL,dt);
          stepNucleons(protons, 0.035, t); stepNucleons(neutrons, 0.035, t);
          orbit.update(dt); renderer.render(scene,camera); requestAnimationFrame(animate); }
        animate();

        addEventListener('resize',()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); },{passive:true});
      }catch(e){ showErr('Excepción al iniciar: '+(e?.message||e)); console.error(e); }
    })();
  </script>
</body>
</html>
