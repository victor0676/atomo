<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Átomo de Nitrógeno 3D — v1</title>
  <meta name="theme-color" content="#14b8a6" />
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#1afd71; color:#ffffff; }
    #app { position:fixed; inset:0; }
    .hud {
      position: fixed; left: 50%; transform: translateX(-50%);
      bottom: 16px; display:flex; gap:.5rem; align-items:center; flex-wrap:wrap;
      background: rgba(2,6,23,.7); border:1px solid rgba(148,163,184,.25);
      padding: .75rem 1rem; border-radius: 14px; backdrop-filter: blur(8px);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto;
      box-shadow: 0 8px 30px rgba(0,0,0,.35);
    }
    .btn {
      appearance:none; border:1px solid rgba(148,163,184,.35); background:#0f172a; color:#e5e7eb; 
      padding:.5rem .8rem; border-radius:12px; cursor:pointer; font-weight:600; font-size:14px;
    }
    .btn.primary { background:#14b8a6; border-color:#2dd4bf; color:#001010; }
    .badge { font-size:12px; opacity:.9 }
    .legend {
      position:fixed; top:12px; left:12px; right:12px; display:flex; gap:.5rem; align-items:center; flex-wrap:wrap;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto;
    }
    .legend > * { background: rgba(2,6,23,.7); border:1px solid rgba(148,163,184,.25);
      padding:.5rem .7rem; border-radius: 12px; }
    .dot { width:12px; height:12px; border-radius:999px; display:inline-block; margin-right:6px; vertical-align:middle; }
    .dot.nucleo { background:#02f784; }
    .dot.electron { background:rgb(19, 255, 59); }
    .dot.capa { background:#190064; }
    #errorBanner {
      position: fixed; top: 0; left: 0; right: 0;
      background: #991b1b; color: #fff; padding: 10px 14px; font-family: ui-sans-serif, system-ui;
      display: none; z-index: 9999;
    }
    .window-toggle {
      position: fixed;
      background: #14b8a6;
      color: #001010;
      border: none;
      padding: 10px 16px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      z-index: 10000;
      transform: translateY(-50%);
    }
    .window {
      position: fixed;
      background: rgba(2,6,23,0.9);
      border: 1px solid rgba(148,163,184,0.25);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 8px 30px rgba(0,0,0,.35);
      z-index: 10000;
    }
  </style>
</head>
<body>
  <div id="errorBanner"></div>
  <div id="app"></div>
  <button class="window-toggle" id="toggleLegend" style="top:12px;left:12px;">Etiquetas</button>
  <button class="window-toggle" id="togglePanel" style="top:12px;right:12px;">Opciones</button>
  <div class="window legend" id="legendWindow" style="display:none; top:60px; left:12px; max-width:340px;">
    <div style="position:static; background:none; border:none; box-shadow:none; padding:0;">
      <div><span class="dot nucleo"></span> Núcleo <small>(7 p<sup>+</sup>, 7 n<sup>0</sup>)</small></div>
      <div><span class="dot electron"></span> Electrones (e<sup>-</sup>)</div>
      <div><span class="dot capa"></span> Capas K (2e<sup>-</sup>), L (5e<sup>−</sup>)</div>
      <div class="badge">Nitrógeno (Z=7) · Config.: 1s² 2s² 2p³</div>
    </div>
  </div>
  <div class="window" id="panelWindow" style="display:none; top:120px; right:8px; max-width:340px;">
    <div class="hud" style="position:static; background:none; border:none; box-shadow:none; padding:0;">
      <div style="margin-bottom:12px;">
        <strong>Vista</strong><br>
        <button id="gyroBtn" class="btn primary">Activar giroscopio</button>
        <button id="autoBtn" class="btn">Auto-rotar</button>
        <button id="resetBtn" class="btn">Reiniciar vista</button>
      </div>
      <div style="margin-bottom:12px;">
        <strong>Elementos</strong><br>
        <button id="toggleOrbitasBtn" class="btn">Mostrar/ocultar órbitas</button>
        <button id="toggleElectronesBtn" class="btn">Mostrar/ocultar electrones</button>
        <button id="toggleProtonesBtn" class="btn">Mostrar/ocultar núcleo</button>
      </div>
      <div style="margin-bottom:12px;">
        <strong>Etiquetas</strong><br>
        <button id="labelsBtn" class="btn">Mostrar etiquetas</button>
      </div>
      <span class="badge">Consejo: pellizca para zoom</span>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
    const banner = document.getElementById('errorBanner');
    function showErr(msg){
      banner.style.display = 'block';
      banner.textContent = msg;
      console.error(msg);
    }
    window.addEventListener('error', (e)=>{
      showErr('Error en el visor: ' + (e?.message || e));
    });
    (function checkWebGL(){
      const canvas = document.createElement('canvas');
      const ok = !!(canvas.getContext('webgl') || canvas.getContext('webgl2'));
      if(!ok){ showErr('Tu navegador no tiene WebGL habilitado. Activa la aceleración por hardware o usa otro navegador.'); }
    })();
    if (!window.THREE){ showErr('No se pudo cargar THREE.js. Revisa tu conexión a internet o políticas de red.'); }
    (function(){
      try {
        const DEG2RAD = (THREE.MathUtils && THREE.MathUtils.degToRad) ? THREE.MathUtils.degToRad : (d => d * Math.PI / 180);
        const app = document.getElementById('app');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0b1220);
        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2.1, 7.5);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        app.appendChild(renderer.domElement);
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);
        const key = new THREE.PointLight(0xffffff, 1.1);
        key.position.set(5, 5, 6);
        scene.add(key);
        const rim = new THREE.PointLight(0x66ccff, 0.8);
        rim.position.set(-6, -3, -4);
        scene.add(rim);
        const starGeo = new THREE.BufferGeometry();
        const starCount = 600;
        const starPos = new Float32Array(starCount * 3);
        for (let i=0;i<starCount;i++){
          const r = 60 * Math.cbrt(Math.random());
          const t = Math.random() * Math.PI * 2;
          const p = Math.acos(2*Math.random()-1);
          starPos[i*3] = r*Math.sin(p)*Math.cos(t);
          starPos[i*3+1] = r*Math.sin(p)*Math.sin(t);
          starPos[i*3+2] = r*Math.cos(p);
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({ size: 0.14, color: 0x93c5fd });
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);
        // Colores personalizados
        const nucleoMat = new THREE.MeshPhysicalMaterial({
          color: 0x3b82f6, // azul núcleo
          roughness: 0.18, metalness: 0.35, clearcoat: 0.7, clearcoatRoughness: 0.18
        });
        const electronMat = new THREE.MeshPhysicalMaterial({
          color: 0xf43f5e, // rosa electrones
          roughness: 0.25, metalness: 0.25
        });
        // Orbitas con colores diferentes
        const ringKMat = new THREE.MeshBasicMaterial({ color: 0xf59e0b, transparent:true, opacity:0.55 }); // amarillo
        const ringLMat = new THREE.MeshBasicMaterial({ color: 0x10b981, transparent:true, opacity:0.55 }); // verde

        const nucleoGeo = new THREE.SphereGeometry(1.1, 64, 64);
        const nucleo = new THREE.Mesh(nucleoGeo, nucleoMat);
        scene.add(nucleo);
        const ringGroup = new THREE.Group();
        const radioK = 2.4;
        const radioL = 3.6;
        const ringK = new THREE.Mesh(new THREE.TorusGeometry(radioK, 0.02, 12, 180), ringKMat);
        const ringL = new THREE.Mesh(new THREE.TorusGeometry(radioL, 0.02, 12, 220), ringLMat);
        ringK.rotation.x = Math.PI/2;
        ringL.rotation.x = Math.PI/2;
        ringGroup.add(ringK, ringL);
        scene.add(ringGroup);
        const electronGeo = new THREE.SphereGeometry(0.18, 24, 24);
        const electronGroup = new THREE.Group();
        scene.add(electronGroup);

        // FUNCION PARA UBICAR ELECTRONES SEGUN CAPA
        function placeElectrons(count, radius, tiltDeg=0, phase=0){
          const grp = new THREE.Group();
          grp.rotation.z = DEG2RAD(tiltDeg);
          for(let i=0;i<count;i++){
            const theta = phase + i * (Math.PI*2 / count);
            const e = new THREE.Mesh(electronGeo, electronMat);
            e.userData = { radius, theta };
            e.position.set(radius*Math.cos(theta), 0, radius*Math.sin(theta));
            grp.add(e);
          }
          electronGroup.add(grp);
          return grp;
        }

        // Nitrógeno: K=2, L=5
        const K = placeElectrons(2, radioK, 0, 0);
        const L = placeElectrons(5, radioL, 14, Math.PI/8);

        // Etiquetas con Sprites
        const labelGroup = new THREE.Group();
        scene.add(labelGroup);

        function makeTextSprite(text, opts={}){
          const pad = opts.pad ?? 8;
          const font = opts.font ?? '600 22px ui-sans-serif, -apple-system, Segoe UI, Roboto';
          const bg = opts.bg ?? 'rgba(2,6,23,0.80)';
          const fg = opts.fg ?? '#e5e7eb';
          const border = opts.border ?? 'rgba(148,163,184,0.35)';
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          ctx.font = font;
          const lines = String(text).split(/<br ?\/?>/i);
          const metrics = lines.map(l => ctx.measureText(l.replace(/<[^>]+>/g,'')));
          const lineHeight = 28;
          const width = Math.max(...metrics.map(m => m.width)) + pad*2;
          const height = lineHeight*lines.length + pad*2;
          const scale = 2;
          canvas.width = Math.ceil(width*scale);
          canvas.height = Math.ceil(height*scale);
          ctx.scale(scale, scale);
          ctx.font = font;
          const r = 10;
          ctx.fillStyle = bg;
          ctx.strokeStyle = border;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(pad+r, pad);
          ctx.lineTo(width-pad-r, pad);
          ctx.quadraticCurveTo(width-pad, pad, width-pad, pad+r);
          ctx.lineTo(width-pad, height-pad-r);
          ctx.quadraticCurveTo(width-pad, height-pad, width-pad-r, height-pad);
          ctx.lineTo(pad+r, height-pad);
          ctx.quadraticCurveTo(pad, height-pad, pad, height-pad-r);
          ctx.lineTo(pad, pad+r);
          ctx.quadraticCurveTo(pad, pad, pad+r, pad);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = fg;
          ctx.textBaseline = 'middle';
          lines.forEach((l, i) => {
            const plain = l.replace(/<[^>]+>/g,'');
            const tm = ctx.measureText(plain);
            ctx.fillText(plain, (width - tm.width)/2, pad + lineHeight*(i+0.5));
          });
          const tex = new THREE.CanvasTexture(canvas);
          tex.minFilter = THREE.LinearFilter;
          tex.magFilter = THREE.LinearFilter;
          const mat = new THREE.SpriteMaterial({ map: tex, depthTest: false, depthWrite: false, transparent: true });
          const sprite = new THREE.Sprite(mat);
          const uiWorldSize = opts.worldSize ?? 0.9;
          sprite.scale.set(uiWorldSize * (width/height), uiWorldSize, 1);
          sprite.renderOrder = 999;
          return sprite;
        }

        const labelNucleo = makeTextSprite('Núcleo\n7 p+ · 7 n0', { worldSize: 0.9 });
        labelNucleo.position.set(0, 1.6, 0);
        nucleo.add(labelNucleo); labelGroup.add(labelNucleo);

        const kAnchor = new THREE.Object3D(); kAnchor.position.set(radioK, 0, 0); scene.add(kAnchor);
        const lAnchor = new THREE.Object3D(); lAnchor.position.set(radioL, 0, 0); scene.add(lAnchor);
        const labelK = makeTextSprite('Capa K · 2 e-', { worldSize: 0.9 });
        kAnchor.add(labelK); labelGroup.add(labelK);
        const labelL = makeTextSprite('Capa L · 5 e-', { worldSize: 0.9 });
        lAnchor.add(labelL); labelGroup.add(labelL);

        const labelEK = makeTextSprite('e-', { worldSize: 0.5 });
        labelEK.position.set(0, 0.45, 0);
        K.children[0].add(labelEK); labelGroup.add(labelEK);

        const labelEL = makeTextSprite('e-', { worldSize: 0.5 });
        labelEL.position.set(0, 0.45, 0);
        L.children[0].add(labelEL); labelGroup.add(labelEL);

        class SimpleOrbit {
          constructor(camera, dom, target=new THREE.Vector3(0,0,0)){
            this.camera = camera; this.dom = dom; this.target = target.clone();
            this.spherical = new THREE.Spherical();
            const offset = new THREE.Vector3().copy(camera.position).sub(this.target);
            this.spherical.setFromVector3(offset);
            this.minDistance = 3.2; this.maxDistance = 14;
            this.rotateSpeed = 1.0; this.zoomSpeed = 1.0;
            this.damping = 0.1;
            this._deltaTheta = 0; this._deltaPhi = 0; this._scale = 1;
            this.autoRotate = false;
            this.autoRotateSpeed = 0.8;
            this._state = null;
            this._pointer = new THREE.Vector2();
            this._pointerStart = new THREE.Vector2();
            this._touchDistance = 0;
            dom.addEventListener('pointerdown', e=>this.onPointerDown(e));
            window.addEventListener('pointermove', e=>this.onPointerMove(e));
            window.addEventListener('pointerup', e=>this.onPointerUp(e), {passive:true});
            dom.addEventListener('wheel', e=>this.onWheel(e), { passive:false });
            dom.addEventListener('touchstart', e=>this.onTouchStart(e), { passive:false });
            dom.addEventListener('touchmove', e=>this.onTouchMove(e), { passive:false });
            dom.addEventListener('touchend', e=>this.onTouchEnd(e));
          }
          onPointerDown(e){
            this.dom.setPointerCapture(e.pointerId);
            this._state = 'rotate';
            this._pointerStart.set(e.clientX, e.clientY);
          }
          onPointerMove(e){
            if (this._state !== 'rotate') return;
            this._pointer.set(e.clientX, e.clientY);
            const dx = (this._pointer.x - this._pointerStart.x) / this.dom.clientHeight;
            const dy = (this._pointer.y - this._pointerStart.y) / this.dom.clientHeight;
            this._deltaTheta -= 2*Math.PI * dx * this.rotateSpeed;
            this._deltaPhi   -= 2*Math.PI * dy * this.rotateSpeed * 0.6;
            this._pointerStart.copy(this._pointer);
          }
          onPointerUp(e){
            this._state = null;
          }
          onWheel(e){
            e.preventDefault();
            const delta = e.deltaY > 0 ? 1 : -1;
            const factor = 1 + (0.08 * this.zoomSpeed);
            this._scale *= delta > 0 ? factor : 1/factor;
          }
          onTouchStart(e){
            if (e.touches.length === 1){
              this._state = 'rotate';
              this._pointerStart.set(e.touches[0].clientX, e.touches[0].clientY);
            } else if (e.touches.length === 2){
              this._state = 'zoom';
              const dx = e.touches[0].clientX - e.touches[1].clientX;
              const dy = e.touches[0].clientY - e.touches[1].clientY;
              this._touchDistance = Math.hypot(dx, dy);
            }
          }
          onTouchMove(e){
            if (this._state === 'rotate' && e.touches.length === 1){
              const x = e.touches[0].clientX, y = e.touches[0].clientY;
              const dx = (x - this._pointerStart.x) / this.dom.clientHeight;
              const dy = (y - this._pointerStart.y) / this.dom.clientHeight;
              this._deltaTheta -= 2*Math.PI * dx * this.rotateSpeed;
              this._deltaPhi   -= 2*Math.PI * dy * this.rotateSpeed * 0.6;
              this._pointerStart.set(x, y);
            } else if (this._state === 'zoom' && e.touches.length === 2){
              const dx = e.touches[0].clientX - e.touches[1].clientX;
              const dy = e.touches[0].clientY - e.touches[1].clientY;
              const dist = Math.hypot(dx, dy);
              const factor = 1 + (Math.abs(dist - this._touchDistance) / 200) * this.zoomSpeed;
              this._scale *= dist < this._touchDistance ? factor : 1/factor;
              this._touchDistance = dist;
            }
            e.preventDefault();
          }
          onTouchEnd(e){ this._state = null; }
          reset(){
            const offset = new THREE.Vector3(0,2.1,7.5).sub(this.target);
            this.spherical.setFromVector3(offset);
          }
          update(dt){
            if (this.autoRotate){ this._deltaTheta -= this.autoRotateSpeed * dt; }
            this.spherical.theta += this._deltaTheta * this.damping;
            this.spherical.phi   += this._deltaPhi   * this.damping;
            this.spherical.makeSafe();
            this.spherical.radius *= this._scale;
            this.spherical.radius = Math.min(this.maxDistance, Math.max(this.minDistance, this.spherical.radius));
            this._deltaTheta *= (1 - this.damping);
            this._deltaPhi   *= (1 - this.damping);
            this._scale = 1;
            const offset = new THREE.Vector3().setFromSpherical(this.spherical);
            this.camera.position.copy(this.target).add(offset);
            this.camera.lookAt(this.target);
          }
        }
        const orbit = new SimpleOrbit(camera, renderer.domElement);
        orbit.autoRotate = false;
        let gyroActive = false;
        let baseBeta = null, baseGamma = null;
        function enableGyro(){
          const anyDevOrient = window.DeviceOrientationEvent;
          const attach = ()=>{
            gyroActive = true;
            baseBeta = null; baseGamma = null;
            window.addEventListener('deviceorientation', (e)=>{
              if (!gyroActive) return;
              if (baseBeta === null){ baseBeta = e.beta || 0; baseGamma = e.gamma || 0; return; }
              const dBeta = (e.beta || 0) - baseBeta;
              const dGamma = (e.gamma || 0) - baseGamma;
              orbit._deltaPhi   -= DEG2RAD(dBeta) * 0.5;
              orbit._deltaTheta += DEG2RAD(dGamma) * 0.5;
            });
          };
          if (anyDevOrient && typeof anyDevOrient.requestPermission === 'function'){
            anyDevOrient.requestPermission().then(state => {
              if (state === 'granted'){ attach(); }
              else alert('Permiso denegado. Puedes usar el dedo para rotar o activar auto-rotación.');
            }).catch(err => alert('No se pudo solicitar permiso: ' + err));
          } else {
            attach();
          }
        }
        const gyroBtn = document.getElementById('gyroBtn');
        const labelsBtn = document.getElementById('labelsBtn');
        const autoBtn = document.getElementById('autoBtn');
        const resetBtn = document.getElementById('resetBtn');
        let labelsVisible = false;
        labelsBtn.addEventListener('click', ()=>{
          labelsVisible = !labelsVisible;
          labelGroup.visible = labelsVisible;
          labelsBtn.textContent = labelsVisible ? 'Ocultar etiquetas' : 'Mostrar etiquetas';
          labelsBtn.classList.toggle('primary', labelsVisible);
        });
        autoBtn.addEventListener('click', ()=>{
          orbit.autoRotate = !orbit.autoRotate;
          autoBtn.classList.toggle('primary', orbit.autoRotate);
          autoBtn.textContent = orbit.autoRotate ? 'Detener auto-rotación' : 'Auto-rotar';
        });
        resetBtn.addEventListener('click', ()=>{
          orbit.reset();
        });
        gyroBtn.addEventListener('click', ()=>{
          if (!gyroActive){ enableGyro(); gyroBtn.textContent='Giroscopio activo'; gyroBtn.disabled = true; }
        });
        const panelWindow = document.getElementById('panelWindow');
        document.getElementById('togglePanel').onclick = () => {
          panelWindow.style.display = panelWindow.style.display === 'none' ? 'block' : 'none';
        };
        const legendWindow = document.getElementById('legendWindow');
        document.getElementById('toggleLegend').onclick = () => {
          legendWindow.style.display = legendWindow.style.display === 'none' ? 'block' : 'none';
        };
        document.getElementById('toggleOrbitasBtn').onclick = () => {
          ringGroup.visible = !ringGroup.visible;
        };
        document.getElementById('toggleElectronesBtn').onclick = () => {
          electronGroup.visible = !electronGroup.visible;
        };
        document.getElementById('toggleProtonesBtn').onclick = () => {
          nucleo.visible = !nucleo.visible;
          labelNucleo.visible = nucleo.visible;
        };
        const clock = new THREE.Clock();
        function animate(){
          const dt = clock.getDelta();
          const t = clock.elapsedTime;
          nucleo.scale.setScalar(1 + Math.sin(t*1.6)*0.015);
          ringGroup.rotation.y += 0.0025;
          K.rotation.y += 0.035;
          L.rotation.y -= 0.02;
          lAnchor.rotation.y += 0.0025;
          orbit.update(dt);
          renderer.render(scene, camera);
          requestAnimationFrame(animate);
        }
        animate();
        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }, { passive:true });
      } catch (e){
        showErr('Excepción al iniciar: ' + (e?.message || e));
        console.error(e);
      }
    })();
  </script>
</body>
</html>